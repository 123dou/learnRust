//æ ‘æ˜¯ä¸€ä¸ªæ— å‘å›¾ï¼Œå…¶ä¸­ä»»ä½•ä¸¤ä¸ªé¡¶ç‚¹åªé€šè¿‡ä¸€æ¡è·¯å¾„è¿æ¥ã€‚ æ¢å¥è¯è¯´ï¼Œä¸€ä¸ªä»»ä½•æ²¡æœ‰ç®€å•ç¯è·¯çš„è¿é€šå›¾éƒ½æ˜¯ä¸€æ£µæ ‘ã€‚
//
// ç»™ä½ ä¸€æ£µåŒ…å« n ä¸ªèŠ‚ç‚¹çš„æ ‘ï¼Œæ ‡è®°ä¸º 0 åˆ° n - 1 ã€‚ç»™å®šæ•°å­— n å’Œä¸€ä¸ªæœ‰ n - 1 æ¡æ— å‘è¾¹çš„ edges åˆ—è¡¨ï¼ˆæ¯ä¸€ä¸ªè¾¹éƒ½æ˜¯ä¸€å¯¹æ ‡ç­¾ï¼‰ï¼Œå…¶ä¸­
// edges[i] = [ai, bi] è¡¨ç¤ºæ ‘ä¸­èŠ‚ç‚¹ ai å’Œ bi ä¹‹é—´å­˜åœ¨ä¸€æ¡æ— å‘è¾¹ã€‚
//
// å¯é€‰æ‹©æ ‘ä¸­ä»»ä½•ä¸€ä¸ªèŠ‚ç‚¹ä½œä¸ºæ ¹ã€‚å½“é€‰æ‹©èŠ‚ç‚¹ x ä½œä¸ºæ ¹èŠ‚ç‚¹æ—¶ï¼Œè®¾ç»“æœæ ‘çš„é«˜åº¦ä¸º h ã€‚åœ¨æ‰€æœ‰å¯èƒ½çš„æ ‘ä¸­ï¼Œå…·æœ‰æœ€å°é«˜åº¦çš„æ ‘ï¼ˆå³ï¼Œmin(h)ï¼‰è¢«ç§°ä¸º æœ€å°é«˜åº¦
//æ ‘ ã€‚
//
// è¯·ä½ æ‰¾åˆ°æ‰€æœ‰çš„ æœ€å°é«˜åº¦æ ‘ å¹¶æŒ‰ ä»»æ„é¡ºåº è¿”å›å®ƒä»¬çš„æ ¹èŠ‚ç‚¹æ ‡ç­¾åˆ—è¡¨ã€‚
//æ ‘çš„ é«˜åº¦ æ˜¯æŒ‡æ ¹èŠ‚ç‚¹å’Œå¶å­èŠ‚ç‚¹ä¹‹é—´æœ€é•¿å‘ä¸‹è·¯å¾„ä¸Šè¾¹çš„æ•°é‡ã€‚
//
//
//
// ç¤ºä¾‹ 1ï¼š
//
//
//è¾“å…¥ï¼šn = 4, edges = [[1,0],[1,2],[1,3]]
//è¾“å‡ºï¼š[1]
//è§£é‡Šï¼šå¦‚å›¾æ‰€ç¤ºï¼Œå½“æ ¹æ˜¯æ ‡ç­¾ä¸º 1 çš„èŠ‚ç‚¹æ—¶ï¼Œæ ‘çš„é«˜åº¦æ˜¯ 1 ï¼Œè¿™æ˜¯å”¯ä¸€çš„æœ€å°é«˜åº¦æ ‘ã€‚
//
// ç¤ºä¾‹ 2ï¼š
//
//
//è¾“å…¥ï¼šn = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]
//è¾“å‡ºï¼š[3,4]
//
//
// ç¤ºä¾‹ 3ï¼š
//
//
//è¾“å…¥ï¼šn = 1, edges = []
//è¾“å‡ºï¼š[0]
//
//
// ç¤ºä¾‹ 4ï¼š
//
//
//è¾“å…¥ï¼šn = 2, edges = [[0,1]]
//è¾“å‡ºï¼š[0,1]
//
//
//
//
//
//
//
// æç¤ºï¼š
//
//
// 1 <= n <= 2 * 104
// edges.length == n - 1
// 0 <= ai, bi < n
// ai != bi
// æ‰€æœ‰ (ai, bi) äº’ä¸ç›¸åŒ
// ç»™å®šçš„è¾“å…¥ ä¿è¯ æ˜¯ä¸€æ£µæ ‘ï¼Œå¹¶ä¸” ä¸ä¼šæœ‰é‡å¤çš„è¾¹
//
// Related Topics å¹¿åº¦ä¼˜å…ˆæœç´¢ å›¾
// ğŸ‘ 321 ğŸ‘ 0

use std::collections::VecDeque;

use crate::leetcode::editor::cn::graph::Graph;

#[cfg(test)]
pub mod tests {
    use super::*;

    #[test]
    fn test_minimum_height_trees() {
        let num = 6;
        let arr = vec![vec![3, 0], vec![3, 1], vec![3, 2], vec![3, 4], vec![5, 4]];
        println!("solution = {:?}", Solution::find_min_height_trees(num, arr));
    }
}

struct Solution {}

//leetcode submit region begin(Prohibit modification and deletion)
impl Solution {
    /**
    è¯æ˜æ€è·¯ï¼š
    å¯¹å½“å‰çš„å›¾(åˆå§‹çš„å›¾æˆ–è€…åˆ æ‰äº†å‰å‡ å±‚å¶å­èŠ‚ç‚¹çš„å›¾)ï¼Œ
    æˆ‘ä»¬è¦æ‰¾çš„æ»¡è¶³é¢˜è®¾çš„æ ¹èŠ‚ç‚¹æ‰€åœ¨ä½ç½®åªæœ‰ä¸¤ç§å¯èƒ½ï¼Œ
    ä¸€ç§åœ¨å½“å‰å›¾çš„å¶å­èŠ‚ç‚¹(å³åº¦ä¸º1çš„èŠ‚ç‚¹)ï¼Œä¸€ç§ä¸ºå†…éƒ¨èŠ‚ç‚¹ï¼Œ
    è‹¥é€‰æ‹©æŸå¶å­èŠ‚ç‚¹1ï¼Œåˆ™è¯¥å¶å­èŠ‚ç‚¹1ä¸ä»»æ„å…¶ä»–å¶å­èŠ‚ç‚¹2çš„è·ç¦»å¿…å®šä¸º:å¶å­1-å†…éƒ¨èŠ‚ç‚¹x-å¶å­2ï¼Œæ·±åº¦ä¸ºè¿™ä¸‰æ®µè¾¹ä¹‹å’Œï¼Œ
    å¿…å¤§äºç­‰äºmax(å†…éƒ¨x-å¶å­1ï¼Œå†…éƒ¨x-å¶å­2)ï¼Œæ‰€ä»¥ç›¸æ¯”äºå¶å­èŠ‚ç‚¹ï¼Œè§£ç©ºé—´åªèƒ½å‡ºç°åœ¨å†…éƒ¨èŠ‚ç‚¹ï¼Œ
    æ¯å±‚æƒ…å†µéƒ½æ˜¯è¿™æ ·ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦å‰¥å¼€å¶å­èŠ‚ç‚¹ç›´åˆ°å†æ— å¯åˆ†çš„å†…éƒ¨èŠ‚ç‚¹ä¸ºæ­¢ã€‚
    */
    pub fn find_min_height_trees(n: i32, edges: Vec<Vec<i32>>) -> Vec<i32> {
        if n == 1 {
            return vec![0];
        }
        let mut graph = Graph::new(n as usize, &edges);
        let mut que = VecDeque::new();
        for i in 0..graph.adj.len() {
            if graph.adj[i].len() == 1 {
                que.push_back(i);
            }
        }
        let mut res: Vec<usize> = vec![];
        while !que.is_empty() {
            res = Vec::with_capacity(que.len());
            res.extend(que.iter());
            println!("res = {:?}", res);
            que.clear();
            for &v in res.iter() {
                if !graph.adj[v].is_empty() {
                    let w = *graph.adj[v].iter().next().unwrap();
                    println!("w = {:?}", w);
                    graph.del_edges(v, w);
                    if graph.adj[w].len() == 1 {
                        que.push_back(w);
                    }
                }
            }
        }
        res.iter().map(|&val| val as i32).collect()
    }
}
//leetcode submit region end(Prohibit modification and deletion)
